<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/3rd-Eden/node-memcached#readme"

    >memcached (v2.2.2)</a>
</h1>
<h4>A fully featured Memcached API client, supporting both single and clustered Memcached servers through consistent hashing and failover/failure. Memcached is rewrite of nMemcached, which will be deprecated in the near future.</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.memcached">module memcached</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memcached.memcached">
            function <span class="apidocSignatureSpan"></span>memcached
            <span class="apidocSignatureSpan">(args, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">memcached.</span>config</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">memcached.</span>connection</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">memcached.</span>memcached.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">memcached.</span>utils</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.memcached.connection">module memcached.connection</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memcached.connection.Available">
            function <span class="apidocSignatureSpan">memcached.connection.</span>Available
            <span class="apidocSignatureSpan">(host, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memcached.connection.IssueLog">
            function <span class="apidocSignatureSpan">memcached.connection.</span>IssueLog
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.memcached.memcached">module memcached.memcached</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memcached.memcached.memcached">
            function <span class="apidocSignatureSpan">memcached.</span>memcached
            <span class="apidocSignatureSpan">(args, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">memcached.memcached.</span>config</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.memcached.memcached.prototype">module memcached.memcached.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memcached.memcached.prototype.add">
            function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>add
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memcached.memcached.prototype.append">
            function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>append
            <span class="apidocSignatureSpan">(key, value, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memcached.memcached.prototype.buffer">
            function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>buffer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memcached.memcached.prototype.cachedump">
            function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>cachedump
            <span class="apidocSignatureSpan">(server, slabid, number, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memcached.memcached.prototype.cas">
            function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>cas
            <span class="apidocSignatureSpan">(key, value, cas, lifetime, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memcached.memcached.prototype.command">
            function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>command
            <span class="apidocSignatureSpan">(queryCompiler, server)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memcached.memcached.prototype.connect">
            function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>connect
            <span class="apidocSignatureSpan">(server, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memcached.memcached.prototype.connectionIssue">
            function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>connectionIssue
            <span class="apidocSignatureSpan">(error, S)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memcached.memcached.prototype.decr">
            function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>decr
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memcached.memcached.prototype.decrement">
            function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>decrement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memcached.memcached.prototype.del">
            function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>del
            <span class="apidocSignatureSpan">(key, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memcached.memcached.prototype.delegateCallback">
            function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>delegateCallback
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memcached.memcached.prototype.delete">
            function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>delete
            <span class="apidocSignatureSpan">(key, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memcached.memcached.prototype.end">
            function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>end
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memcached.memcached.prototype.flush">
            function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>flush
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memcached.memcached.prototype.flushAll">
            function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>flushAll
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memcached.memcached.prototype.get">
            function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>get
            <span class="apidocSignatureSpan">(key, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memcached.memcached.prototype.getMulti">
            function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>getMulti
            <span class="apidocSignatureSpan">(keys, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memcached.memcached.prototype.gets">
            function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>gets
            <span class="apidocSignatureSpan">(key, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memcached.memcached.prototype.incr">
            function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>incr
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memcached.memcached.prototype.increment">
            function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>increment
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memcached.memcached.prototype.items">
            function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>items
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memcached.memcached.prototype.makeCallback">
            function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>makeCallback
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memcached.memcached.prototype.multi">
            function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>multi
            <span class="apidocSignatureSpan">(keys, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memcached.memcached.prototype.prepend">
            function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>prepend
            <span class="apidocSignatureSpan">(key, value, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memcached.memcached.prototype.rawDataReceived">
            function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>rawDataReceived
            <span class="apidocSignatureSpan">(S)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memcached.memcached.prototype.replace">
            function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>replace
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memcached.memcached.prototype.set">
            function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>set
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memcached.memcached.prototype.settings">
            function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>settings
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memcached.memcached.prototype.slabs">
            function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>slabs
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memcached.memcached.prototype.stats">
            function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>stats
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memcached.memcached.prototype.statsItems">
            function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>statsItems
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memcached.memcached.prototype.statsSettings">
            function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>statsSettings
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memcached.memcached.prototype.statsSlabs">
            function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>statsSlabs
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memcached.memcached.prototype.touch">
            function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>touch
            <span class="apidocSignatureSpan">(key, lifetime, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memcached.memcached.prototype.version">
            function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>version
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.memcached.utils">module memcached.utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memcached.utils.Iterator">
            function <span class="apidocSignatureSpan">memcached.utils.</span>Iterator
            <span class="apidocSignatureSpan">(collection, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memcached.utils.curry">
            function <span class="apidocSignatureSpan">memcached.utils.</span>curry
            <span class="apidocSignatureSpan">(context, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memcached.utils.escapeValue">
            function <span class="apidocSignatureSpan">memcached.utils.</span>escapeValue
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memcached.utils.fuse">
            function <span class="apidocSignatureSpan">memcached.utils.</span>fuse
            <span class="apidocSignatureSpan">(target, handlers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memcached.utils.merge">
            function <span class="apidocSignatureSpan">memcached.utils.</span>merge
            <span class="apidocSignatureSpan">(target, obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memcached.utils.reallocString">
            function <span class="apidocSignatureSpan">memcached.utils.</span>reallocString
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memcached.utils.unescapeValue">
            function <span class="apidocSignatureSpan">memcached.utils.</span>unescapeValue
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memcached.utils.validateArg">
            function <span class="apidocSignatureSpan">memcached.utils.</span>validateArg
            <span class="apidocSignatureSpan">(args, config)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.memcached" id="apidoc.module.memcached">module memcached</a></h1>


    <h2>
        <a href="#apidoc.element.memcached.memcached" id="apidoc.element.memcached.memcached">
        function <span class="apidocSignatureSpan"></span>memcached
        <span class="apidocSignatureSpan">(args, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Client(args, options) {
  var servers = []
    , weights = {}
    , regular = &#x27;localhost:11211&#x27;
    , key;

  // Parse down the connection arguments
  switch (Object.prototype.toString.call(args)) {
    case &#x27;[object Object]&#x27;:
      weights = args;
      servers = Object.keys(args);
      break;

    case &#x27;[object Array]&#x27;:
      servers = args.length ? args : [regular];
      break;

    default:
      servers.push(args || regular);
      break;
  }

  if (!servers.length) {
    throw new Error(&#x27;No servers where supplied in the arguments&#x27;);
  }

  // merge with global and user config
  Utils.merge(this, Client.config);
  Utils.merge(this, options);

  this.servers = servers;
  var compatibility = this.compatibility || this.compatiblity;
  this.HashRing = new HashRing(args, this.algorithm, {
    &#x27;compatibility&#x27;: compatibility,
    &#x27;default port&#x27;: compatibility === &#x27;ketama&#x27; ? 11211 : null
  });
  this.connections = {};
  this.issues = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.memcached.connection" id="apidoc.module.memcached.connection">module memcached.connection</a></h1>


    <h2>
        <a href="#apidoc.element.memcached.connection.Available" id="apidoc.element.memcached.connection.Available">
        function <span class="apidocSignatureSpan">memcached.connection.</span>Available
        <span class="apidocSignatureSpan">(host, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ping(host, callback) {
  var isWin = process.platform.indexOf(&#x27;win&#x27;) === 0; // win32 or win64
  var arg = isWin ? &#x27;-n&#x27; : &#x27;-c&#x27;;
  var pong = spawn(&#x27;ping&#x27;, [arg, &#x27;3&#x27;, host]); // only ping 3 times

  pong.stdout.on(&#x27;data&#x27;, function stdoutdata (data) {
    callback(false, data.toString().split(&#x27;\n&#x27;)[0].substr(14));
    pong.kill();
  });

  pong.stderr.on(&#x27;data&#x27;, function stderrdata (data) {
    callback(new Error(data.toString().split(&#x27;\n&#x27;)[0].substr(14)), false);
    pong.kill();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memcached.connection.IssueLog" id="apidoc.element.memcached.connection.IssueLog">
        function <span class="apidocSignatureSpan">memcached.connection.</span>IssueLog
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function IssueLog(args) {
  this.config = args;
  this.messages = [];
  this.failed = false;
  this.locked = false;
  this.isScheduledToReconnect = false;

  this.totalFailures = 0;
  this.retry = 0;
  this.totalReconnectsAttempted = 0;
  this.totalReconnectsSuccess = 0;

  Utils.merge(this, args);
  EventEmitter.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.memcached.memcached" id="apidoc.module.memcached.memcached">module memcached.memcached</a></h1>


    <h2>
        <a href="#apidoc.element.memcached.memcached.memcached" id="apidoc.element.memcached.memcached.memcached">
        function <span class="apidocSignatureSpan">memcached.</span>memcached
        <span class="apidocSignatureSpan">(args, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Client(args, options) {
  var servers = []
    , weights = {}
    , regular = &#x27;localhost:11211&#x27;
    , key;

  // Parse down the connection arguments
  switch (Object.prototype.toString.call(args)) {
    case &#x27;[object Object]&#x27;:
      weights = args;
      servers = Object.keys(args);
      break;

    case &#x27;[object Array]&#x27;:
      servers = args.length ? args : [regular];
      break;

    default:
      servers.push(args || regular);
      break;
  }

  if (!servers.length) {
    throw new Error(&#x27;No servers where supplied in the arguments&#x27;);
  }

  // merge with global and user config
  Utils.merge(this, Client.config);
  Utils.merge(this, options);

  this.servers = servers;
  var compatibility = this.compatibility || this.compatiblity;
  this.HashRing = new HashRing(args, this.algorithm, {
    &#x27;compatibility&#x27;: compatibility,
    &#x27;default port&#x27;: compatibility === &#x27;ketama&#x27; ? 11211 : null
  });
  this.connections = {};
  this.issues = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.memcached.memcached.prototype" id="apidoc.module.memcached.memcached.prototype">module memcached.memcached.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.memcached.memcached.prototype.add" id="apidoc.element.memcached.memcached.prototype.add">
        function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>add
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bowlofcurry() {
  return fn.apply(context || this, args.concat(copy.call(arguments)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

* `key`: **String** the name of the key
* `value`: **Mixed** Either a buffer, JSON, number or string that you want to store.
* `lifetime`: **Number**, how long the data needs to be replaced measured in `seconds`
* `callback`: **Function** the callback

```js
memcached.<span class="apidocCodeKeywordSpan">add</span>(&#x27;foo&#x27;, &#x27;bar&#x27;, 10, function (err) { /* stuff */ });
```

**memcached.cas** Add the value, only if it matches the given CAS value.

* `key`: **String** the name of the key
* `value`: **Mixed** Either a buffer, JSON, number or string that you want to store.
* `lifetime`: **Number**, how long the data needs to be replaced measured in `seconds`
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memcached.memcached.prototype.append" id="apidoc.element.memcached.memcached.prototype.append">
        function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>append
        <span class="apidocSignatureSpan">(key, value, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function append(key, value, callback) {
  privates.setters.call(this
    , &#x27;append&#x27;
    , [
          [&#x27;key&#x27;, String]
        , [&#x27;value&#x27;, String]
        , [&#x27;lifetime&#x27;, Number]
        , [&#x27;callback&#x27;, Function]
      ]
    , key
    , value
    , 0
    , callback
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
**memcached.append** Add the given value string to the value of an existing item.

* `key`: **String** the name of the key
* `value`: **Mixed** Either a buffer, JSON, number or string that you want to store.
* `callback`: **Function** the callback

```js
memcached.<span class="apidocCodeKeywordSpan">append</span>(&#x27;foo&#x27;, &#x27;bar&#x27;, function (err) { /* stuff */ });
```

**memcached.prepend** Add the given value string to the value of an existing item.

* `key`: **String** the name of the key
* `value`: **Mixed** Either a buffer, JSON, number or string that you want to store.
* `callback`: **Function** the callback
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memcached.memcached.prototype.buffer" id="apidoc.element.memcached.memcached.prototype.buffer">
        function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>buffer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function buffer() {
  return privates.buffer.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Build up our chunk data
chunks.push(chunk.replace(&#x27;{key}&#x27;, 1).replace(&#x27;{length}&#x27;, chunkJSON.length));
chunks.push(chunkJSON);
chunks.push(chunk.replace(&#x27;{key}&#x27;, 2).replace(&#x27;{length}&#x27;, chunkJSON.length));

// Insert first chunk
memcached.<span class="apidocCodeKeywordSpan">buffer</span>(S, chunks.join(&#x27;\r\n&#x27;) +&#x27;\r\n&#x27;);

// We check for bufferArray length otherwise it will crash on &#x27;SyntaxError: Unexpected token V&#x27;
assert.equal(S.bufferArray.length, 3);

// Now add the value of the last response key in previous chunk
chunks.unshift(chunkJSON);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memcached.memcached.prototype.cachedump" id="apidoc.element.memcached.memcached.prototype.cachedump">
        function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>cachedump
        <span class="apidocSignatureSpan">(server, slabid, number, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cachedump(server, slabid, number, callback) {
  this.command(function cachedumpCommand(noreply) {
    return {
        callback: callback
      , number: number
      , slabid: slabid
      , validate: [
            [&#x27;number&#x27;, Number]
          , [&#x27;slabid&#x27;, Number]
          , [&#x27;callback&#x27;, Function]
        ]
      , type: &#x27;stats cachedump&#x27;
      , command: &#x27;stats cachedump &#x27; + slabid + &#x27; &#x27; + number
    };
  }, server);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	result.forEach(function( itemSet ){
		var keys = Object.keys( itemSet );
			keys.pop(); // we don&#x27;t need the &#x22;server&#x22; key, but the other indicate the slab id&#x27;s
			
		keys.forEach(function( stats ){
			
			// get a cachedump for each slabid and slab.number
			memcached.<span class="apidocCodeKeywordSpan">cachedump</span>( itemSet.server, stats, itemSet[stats].number, function( err,
response ){
				// dump the shizzle
				console.info( JSON.stringify( response ) );
				console.log( response.key );
			})
		})
	})
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memcached.memcached.prototype.cas" id="apidoc.element.memcached.memcached.prototype.cas">
        function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>cas
        <span class="apidocSignatureSpan">(key, value, cas, lifetime, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function checkandset(key, value, cas, lifetime, callback) {
  privates.setters.call(this
    , &#x27;cas&#x27;
    , [
          [&#x27;key&#x27;, String]
        , [&#x27;value&#x27;, String]
        , [&#x27;lifetime&#x27;, Number]
        , [&#x27;callback&#x27;, Function]
      ]
    , key
    , value
    , lifetime
    , callback
    , cas
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `value`: **Mixed** Either a buffer, JSON, number or string that you want to store.
* `lifetime`: **Number**, how long the data needs to be replaced measured in `seconds`
* `cas`: **String** the CAS value
* `callback`: **Function** the callback

```js
memcached.gets(&#x27;foo&#x27;, function (err, data) {
  memcached.<span class="apidocCodeKeywordSpan">cas</span>(&#x27;foo&#x27;, &#x27;bar&#x27;, data.cas, 10, function (err) { /* stuff
 */ });
});
```

**memcached.append** Add the given value string to the value of an existing item.

* `key`: **String** the name of the key
* `value`: **Mixed** Either a buffer, JSON, number or string that you want to store.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memcached.memcached.prototype.command" id="apidoc.element.memcached.memcached.prototype.command">
        function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>command
        <span class="apidocSignatureSpan">(queryCompiler, server)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function memcachedCommand(queryCompiler, server) {

    this.activeQueries++;
    var query = queryCompiler();

    if (this.activeQueries&#x3e; this.maxQueueSize &#x26;&#x26; this.maxQueueSize &#x3e; 0){
        this.makeCallback(query.callback, &#x22;over queue limit&#x22;, null);
        query = null;
        return;
    }

    // generate a regular query,
    var redundancy = this.redundancy &#x26;&#x26; this.redundancy &#x3c; this.servers.length
    , queryRedundancy = query.redundancyEnabled
    , memcached = this;

  // validate the arguments
  if (query.validate &#x26;&#x26; !Utils.validateArg(query, this)) {
      this.activeQueries--;
      return;
  }

  // try to find the correct server for this query
  if (!server) {
    // no need to do a hashring lookup if we only have one server assigned to
    // us
    if (this.servers.length === 1) {
      server = this.servers[0];
    } else {
      if (redundancy &#x26;&#x26; queryRedundancy) {
        redundancy = this.HashRing.createRange(query.key, (this.redundancy + 1), true);
        server = redundancy.shift();
      } else {
        server = this.HashRing.get(query.key);
      }
    }
  }

  // check if any server exists or and if the server is still alive
  // a server may not exist if the manager was never able to connect
  // to any server.
  if (!server || (server in this.issues &#x26;&#x26; this.issues[server].failed)) {
    return query.callback &#x26;&#x26; memcached.makeCallback(query.callback,new Error([&#x27;Server at&#x27;, server, &#x27;not available&#x27;].join(&#x27; &#x27;)));
  }

  this.connect(server, function allocateMemcachedConnection(error, S) {
    if (memcached.debug) {
      query.command.split(LINEBREAK).forEach(function errors(line) {
        console.log(S.streamID + &#x27; &#x3c;&#x3c; &#x27; + line);
      });
    }

    // S not set if unable to connect to server
    if (!S) {
      var S = {
        serverAddress: server,
        tokens: server.split(&#x27;:&#x27;).reverse()
      }
      var message = error || &#x27;Unable to connect to server&#x27;;
      memcached.connectionIssue(message, S);
      return query.callback &#x26;&#x26; memcached.makeCallback(query.callback,new Error(message));

    }

    // Other errors besides inability to connect to server
    if (error) {
      memcached.connectionIssue(error.toString(), S);
      return query.callback &#x26;&#x26; memcached.makeCallback(query.callback,error);
    }

    if (S.readyState !== &#x27;open&#x27;) {
      var message = &#x27;Connection readyState is set to &#x27; + S.readyState;
      memcached.connectionIssue(message, S);
      return query.callback &#x26;&#x26; memcached.makeCallback(query.callback,new Error(message));
    }

    // used for request timing
    query.start = Date.now();
    S.metaData.push(query);
    S.write(Utils.reallocString(query.command + LINEBREAK));
  });

  // if we have redundancy enabled and the query is used for redundancy, than
  // we are going loop over the servers, check if we can reach them, and
  // connect to the correct net connection. because all redundancy queries are
  // executed with &#x22;no reply&#x22; we do not need to store the callback as there
  // will be no value to parse.
  if (redundancy &#x26;&#x26; queryRedundancy) {
    queryRedundancy = queryCompiler(queryRedundancy);

    redundancy.forEach(function each(server) {
      if (server in memcached.issues &#x26;&#x26; memcached.issues[server].failed){
          return;
      }

      memcached.connect(server, function allocateMemcachedConnection(error, S) {
        if (!S || error || S.readyState !== &#x27;open&#x27;) return;
        S.write(queryRedundancy.command + LINEBREAK);
      });
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

* `query`: *Object*, The metaData object, see the `Callbacks` section for the
specification.
* `server`: *String*, The server the to connect. This is only needed when the
metaData object doesn&#x27;t contain a key property to retrieve the server from.

``` js
memcached.<span class="apidocCodeKeywordSpan">command</span>({
key: &#x27;key&#x27;, callback: function(){ console.dir( arguments ); },

// validate the arguments
validate: [[ &#x27;key&#x27;, String ], [ &#x27;callback&#x27;, Function ]],

// used for the query
type: &#x27;delete&#x27;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memcached.memcached.prototype.connect" id="apidoc.element.memcached.memcached.prototype.connect">
        function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>connect
        <span class="apidocSignatureSpan">(server, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function connect(server, callback) {
  // Default port to 11211
  if(!server.match(/(.+):(\d+)$/)) {
      server = server + &#x27;:11211&#x27;;
  }

  // server is dead, bail out
  if (server in this.issues &#x26;&#x26; this.issues[server].failed) {
      return callback(false, false);
  }

  // fetch from connection pool
  if (server in this.connections) {
    return this.connections[server].pull(callback);
  }

  // No connection factory created yet, so we must build one
  var serverTokens = server[0] === &#x27;/&#x27;
      ? server
      : /(.*):(\d+){1,}$/.exec(server).reverse()
    , memcached = this;

  // Pop original string from array
  if (Array.isArray(serverTokens)) serverTokens.pop();

  var sid = 0
    , manager;

<span class="apidocCodeCommentSpan">  /**
   * Generate a new connection pool manager.
   */
</span>
  manager = new Jackpot(this.poolSize);
  manager.retries = memcached.retries;
  manager.factor = memcached.factor;
  manager.minTimeout = memcached.minTimeout;
  manager.maxTimeout = memcached.maxTimeout;
  manager.randomize = memcached.randomize;

  manager.setMaxListeners(0);

  manager.factory(function factory() {
    var S = Array.isArray(serverTokens)
        ? new Stream
        : new Socket
      , Manager = this
      , idleTimeout = function() {
          Manager.remove(this);
        }
      , streamError = function(e) {
          memcached.connectionIssue(e.toString(), S);
          Manager.remove(this);
      };

    // config the Stream
    S.streamID = sid++;
    S.setTimeout(memcached.timeout);
    S.setNoDelay(true);
    S.setEncoding(&#x27;utf8&#x27;);
    S.metaData = [];
    S.responseBuffer = &#x22;&#x22;;
    S.bufferArray = [];
    S.serverAddress = server;
    S.tokens = [].concat(serverTokens);
    S.memcached = memcached;

    // Add the event listeners
    Utils.fuse(S, {
        close: function streamClose() {
          Manager.remove(this);
        }
      , data: curry(memcached, privates.buffer, S)
      , connect: function streamConnect() {
          // Jackpot handles any pre-connect timeouts by calling back
          // with the error object.
          this.setTimeout(this.memcached.idle, idleTimeout);
          // Jackpot handles any pre-connect errors, but does not handle errors
          // once a connection has been made, nor does Jackpot handle releasing
          // connections if an error occurs post-connect
          this.on(&#x27;error&#x27;, streamError);
        }
      , end: S.end
    });

    // connect the net.Stream (or net.Socket) [port, hostname]
    S.connect.apply(S, S.tokens);
    return S;
  });

  manager.on(&#x27;error&#x27;, function err(e) {
    if (memcached.debug) console.log(&#x27;Connection error&#x27;, e);
  });

  this.connections[server] = manager;

  // now that we have setup our connection factory we can allocate a new
  // connection
  this.connections[server].pull(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
If there are issues with the server connection, we are going to respond with cache-miss pattern.

* `server`: *String*, The server that needs a connection, the format must be
confirm the server_locations specification.
* `callback`: *Function*, The callback function that receives the net.Stre

``` js
memcached.<span class="apidocCodeKeywordSpan">connect</span>( &#x27;192.168.0.103:11211&#x27;, function( err, conn ){
  if( err ) throw new Error( err );
  console.log( conn.server );
});
```

**.multi** A small wrapper function that makes it easier to query multiple Memcached
servers. It will return the location for each key or the complete list of
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memcached.memcached.prototype.connectionIssue" id="apidoc.element.memcached.memcached.prototype.connectionIssue">
        function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>connectionIssue
        <span class="apidocSignatureSpan">(error, S)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function connectionIssue(error, S) {
  if (S &#x26;&#x26; S.end) S.end();

  var issues
    , server = S.serverAddress
    , memcached = this;

  // check for existing issue logs, or create a new log
  if (server in this.issues) {
    issues = this.issues[server];
  } else {
    issues = this.issues[server] = new IssueLog({
        server: server
      , tokens: S.tokens
      , reconnect: this.reconnect
      , failures: this.failures
      , failuresTimeout: this.failuresTimeout
      , retry: this.retry
      , remove: this.remove
      , failOverServers: this.failOverServers || null
    });

    // proxy the events
    Utils.fuse(issues, {
        issue: function issue(details) {
          memcached.emit(&#x27;issue&#x27;, details);
        }
      , failure: function failure(details) {
          memcached.emit(&#x27;failure&#x27;, details);
        }
      , reconnecting: function reconnect(details) {
          memcached.emit(&#x27;reconnecting&#x27;, details);
        }
      , reconnected: function reconnected(details) {
          memcached.emit(&#x27;reconnect&#x27;, details);
        }
      , remove: function remove(details) {
          // emit event and remove servers
          memcached.emit(&#x27;remove&#x27;, details);
          memcached.connections[server].end();

          if (this.failOverServers &#x26;&#x26; this.failOverServers.length) {
            memcached.HashRing.swap(server, this.failOverServers.shift());
          } else {
            memcached.HashRing.remove(server);
            memcached.emit(&#x27;failure&#x27;, details);
          }
        }
    });

    // bumpt the event listener limit
    issues.setMaxListeners(0);
  }

  // log the issue
  issues.log(error);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `error`: *String*, The actual error message.
* `Stream`: *net.Stream*, A reference to the connection stream where the error
occurred on.
* `callback`: *Function* **(optional)**, The callback function of a potential
request, it will be marked as cache miss if it was provided

``` js
memcached.<span class="apidocCodeKeywordSpan">connectionIssue</span>( &#x22;Server down&#x22;, connectionReference );
```

## Callbacks

Each method requires a callback function. Once this function get executed there
will be 2 variables applied:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memcached.memcached.prototype.decr" id="apidoc.element.memcached.memcached.prototype.decr">
        function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>decr
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bowlofcurry() {
  return fn.apply(context || this, args.concat(copy.call(arguments)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
**memcached.decr** Decrement a given key.

* `key`: **String** the name of the key
* `amount`: **Number** The increment
* `callback`: **Function** the callback

```js
memcached.<span class="apidocCodeKeywordSpan">decr</span>(&#x27;foo&#x27;, 10, function (err) { /* stuff */ });
```

**memcached.del** Remove the key from memcached.

* `key`: **String** the name of the key
* `callback`: **Function** the callback
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memcached.memcached.prototype.decrement" id="apidoc.element.memcached.memcached.prototype.decrement">
        function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>decrement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bowlofcurry() {
  return fn.apply(context || this, args.concat(copy.call(arguments)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var	nMemcached = require( &#x27;../&#x27; ),
	memcached;

// connect to our memcached server on host 10.211.55.5, port 11211
memcached = new nMemcached( &#x22;10.211.55.5:11211&#x22; );

memcached.<span class="apidocCodeKeywordSpan">decrement</span>( &#x22;hello&#x22;, 1, function( err, result ){
	if( err ) console.error( err );
	
	console.log(&#x22;result:&#x22; + result );
	memcached.end(); // as we are 100% certain we are not going to use the connection again, we are going to end it
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memcached.memcached.prototype.del" id="apidoc.element.memcached.memcached.prototype.del">
        function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>del
        <span class="apidocSignatureSpan">(key, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function del(key, callback){
  var fullkey = this.namespace + key;
  this.command(function deleteCommand(noreply) {
    return {
        key: fullkey
      , callback: callback
      , validate: [
            [&#x27;key&#x27;, String]
          , [&#x27;callback&#x27;, Function]
        ]
      , type: &#x27;delete&#x27;
      , redundancyEnabled: true
      , command: &#x27;delete &#x27; + fullkey +
             (noreply ? NOREPLY : &#x27;&#x27;)
    };
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

**memcached.del** Remove the key from memcached.

* `key`: **String** the name of the key
* `callback`: **Function** the callback

```js
memcached.<span class="apidocCodeKeywordSpan">del</span>(&#x27;foo&#x27;, function (err) { /* stuff */ });
```

**memcached.version** Retrieves the version number of your server.

* `callback`

**memcached.flush** Flushes the memcached server.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memcached.memcached.prototype.delegateCallback" id="apidoc.element.memcached.memcached.prototype.delegateCallback">
        function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>delegateCallback
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delegateCallback = function (){
      this.activeQueries--;
      var master = arguments[0];
      var cb = arguments[arguments.length-1];
      var args = Array.prototype.slice.call(arguments, 1, arguments.length-1);
      cb.apply(master, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else {
    servers = this.servers;
  }

  i = servers.length;

  while (i--) {
     //memcached.<span class="apidocCodeKeywordSpan">delegateCallback</span>(this, servers[i], map[servers[i]], i, servers.length
, callback);
    callback.call(this, servers[i], map[servers[i]], i, servers.length);
  }
};

// Executes the command on the net.Stream, if no server is supplied it will
// use the query.key to get the server from the HashRing
memcached.command = function memcachedCommand(queryCompiler, server) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memcached.memcached.prototype.delete" id="apidoc.element.memcached.memcached.prototype.delete">
        function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>delete
        <span class="apidocSignatureSpan">(key, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function del(key, callback){
  var fullkey = this.namespace + key;
  this.command(function deleteCommand(noreply) {
    return {
        key: fullkey
      , callback: callback
      , validate: [
            [&#x27;key&#x27;, String]
          , [&#x27;callback&#x27;, Function]
        ]
      , type: &#x27;delete&#x27;
      , redundancyEnabled: true
      , command: &#x27;delete &#x27; + fullkey +
             (noreply ? NOREPLY : &#x27;&#x27;)
    };
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memcached.memcached.prototype.end" id="apidoc.element.memcached.memcached.prototype.end">
        function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>end
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function endMemcached() {
  var memcached = this;

  Object.keys(this.connections).forEach(function closeConnection(key) {
    memcached.connections[key].free(0);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

	// check if the data was stored
	assert.equal( success, true, &#x22;Successfully stored data&#x22; )

	memcached.get( &#x22;hello_world&#x22;, function( err, success ){
		assert.equal( success, &#x22;greetings from planet node&#x22;, &#x22;Failed to fetched data&#x22; )
		process.stdout.write( success );
		memcached.<span class="apidocCodeKeywordSpan">end</span>()
	});
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memcached.memcached.prototype.flush" id="apidoc.element.memcached.memcached.prototype.flush">
        function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>flush
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bowlofcurry() {
  return fn.apply(context || this, args.concat(copy.call(arguments)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var	nMemcached = require( &#x27;../&#x27; ),
	memcached;

// connect to our memcached server on host 10.211.55.5, port 11211
memcached = new nMemcached( &#x22;10.211.55.5:11211&#x22; );

memcached.<span class="apidocCodeKeywordSpan">flush</span>( function( err, result ){
	if( err ) console.error( err );
	
	console.log( JSON.stringify ( result ));
	memcached.end(); // as we are 100% certain we are not going to use the connection again, we are going to end it
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memcached.memcached.prototype.flushAll" id="apidoc.element.memcached.memcached.prototype.flushAll">
        function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>flushAll
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bowlofcurry() {
  return fn.apply(context || this, args.concat(copy.call(arguments)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memcached.memcached.prototype.get" id="apidoc.element.memcached.memcached.prototype.get">
        function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>get
        <span class="apidocSignatureSpan">(key, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function get(key, callback) {
  if (Array.isArray(key)) return this.getMulti.apply(this, arguments);

  var fullkey = this.namespace + key;
  this.command(function getCommand(noreply) {
    return {
        key: fullkey
      , callback: callback
      , validate: [[&#x27;key&#x27;, String], [&#x27;callback&#x27;, Function]]
      , type: &#x27;get&#x27;
      , command: &#x27;get &#x27; + fullkey
    };
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

**memcached.get** Get the value for the given key.

* `key`: **String**, the key
* `callback`: **Function**, the callback.

```js
memcached.<span class="apidocCodeKeywordSpan">get</span>(&#x27;foo&#x27;, function (err, data) {
  console.log(data);
});
```

**memcached.gets** Get the value and the CAS id.

* `key`: **String**, the key
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memcached.memcached.prototype.getMulti" id="apidoc.element.memcached.memcached.prototype.getMulti">
        function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>getMulti
        <span class="apidocSignatureSpan">(keys, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getMulti(keys, callback) {
  var memcached = this
    , responses = {}
    , errors = []
    , calls;

  if (memcached.namespace.length) keys = keys.map(function compile(key){
    return memcached.namespace + key;
  });

  // handle multiple responses and cache them untill we receive all.
  function handle(err, results) {
    if (err) {
      errors.push(err);
    }

    // add all responses to the array
    (Array.isArray(results) ? results : [results]).forEach(function each(value) {
      if (value &#x26;&#x26; memcached.namespace.length) {
        var ns_key = Object.keys(value)[0]
          , newvalue = {};

        newvalue[ns_key.replace(memcached.namespace, &#x27;&#x27;)] = value[ns_key];
        Utils.merge(responses, newvalue);
      } else {
        Utils.merge(responses, value);
      }
    });

    if (!--calls){
        callback(errors.length ? errors : undefined, responses);
    }
  }

  this.multi(keys, function multi(server, key, index, totals) {
    if (!calls) calls = totals;

    memcached.command(function getMultiCommand(noreply) {
      return {
          callback: handle
        , multi: true
        , type: &#x27;get&#x27;
        , command: &#x27;get &#x27; + key.join(&#x27; &#x27;)
        , key: keys
        , validate: [[&#x27;key&#x27;, Array], [&#x27;callback&#x27;, Function]]
      };
    }, server);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```
**memcached.getMulti** Retrieves a bunch of values from multiple keys.

* `keys`: **Array**, all the keys that needs to be fetched
* `callback`: **Function**, the callback.

```js
memcached.<span class="apidocCodeKeywordSpan">getMulti</span>([&#x27;foo&#x27;, &#x27;bar&#x27;], function (err, data) {
  console.log(data.foo);
  console.log(data.bar);
});
```

**memcached.set** Stores a new value in Memcached.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memcached.memcached.prototype.gets" id="apidoc.element.memcached.memcached.prototype.gets">
        function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>gets
        <span class="apidocSignatureSpan">(key, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function get(key, callback) {
  var fullkey = this.namespace + key;
  this.command(function getCommand(noreply) {
    return {
        key: fullkey
      , callback: callback
      , validate: [[&#x27;key&#x27;, String], [&#x27;callback&#x27;, Function]]
      , type: &#x27;gets&#x27;
      , command: &#x27;gets &#x27; + fullkey
    };
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

**memcached.gets** Get the value and the CAS id.

* `key`: **String**, the key
* `callback`: **Function**, the callback.

```js
memcached.<span class="apidocCodeKeywordSpan">gets</span>(&#x27;foo&#x27;, function (err, data) {
  console.log(data.foo);
  console.log(data.cas);

  // Please note that the data is stored under the name of the given key.
});
```
**memcached.getMulti** Retrieves a bunch of values from multiple keys.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memcached.memcached.prototype.incr" id="apidoc.element.memcached.memcached.prototype.incr">
        function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>incr
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bowlofcurry() {
  return fn.apply(context || this, args.concat(copy.call(arguments)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
**memcached.incr** Increment a given key.

* `key`: **String** the name of the key
* `amount`: **Number** The increment
* `callback`: **Function** the callback

```js
memcached.<span class="apidocCodeKeywordSpan">incr</span>(&#x27;foo&#x27;, 10, function (err) { /* stuff */ });
```

**memcached.decr** Decrement a given key.

* `key`: **String** the name of the key
* `amount`: **Number** The increment
* `callback`: **Function** the callback
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memcached.memcached.prototype.increment" id="apidoc.element.memcached.memcached.prototype.increment">
        function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>increment
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bowlofcurry() {
  return fn.apply(context || this, args.concat(copy.call(arguments)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var	nMemcached = require( &#x27;../&#x27; ),
	memcached;

// connect to our memcached server on host 10.211.55.5, port 11211
memcached = new nMemcached( &#x22;10.211.55.5:11211&#x22; );

memcached.<span class="apidocCodeKeywordSpan">increment</span>( &#x22;hello&#x22;, 1, function( err, result ){
	if( err ) console.error( err );
	
	console.log(&#x22;result:&#x22; + result );
	memcached.end(); // as we are 100% certain we are not going to use the connection again, we are going to end it
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memcached.memcached.prototype.items" id="apidoc.element.memcached.memcached.prototype.items">
        function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>items
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bowlofcurry() {
  return fn.apply(context || this, args.concat(copy.call(arguments)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var	nMemcached = require( &#x27;../&#x27; ),
	memcached;

// connect to our memcached server on host 10.211.55.5, port 11211
memcached = new nMemcached( &#x22;10.211.55.6:11211&#x22; );

memcached.<span class="apidocCodeKeywordSpan">items</span>( function( err, result ){
	if( err ) console.error( err );
	
	// for each server...
	result.forEach(function( itemSet ){
		var keys = Object.keys( itemSet );
			keys.pop(); // we don&#x27;t need the &#x22;server&#x22; key, but the other indicate the slab id&#x27;s
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memcached.memcached.prototype.makeCallback" id="apidoc.element.memcached.memcached.prototype.makeCallback">
        function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>makeCallback
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeCallback = function (cb){
     this.activeQueries--;
     var args = Array.prototype.slice.call(arguments, 1);
     cb.apply(this, args); //loose first
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // use the query.key to get the server from the HashRing
  memcached.command = function memcachedCommand(queryCompiler, server) {

this.activeQueries++;
var query = queryCompiler();

if (this.activeQueries&#x3e; this.maxQueueSize &#x26;&#x26; this.maxQueueSize &#x3e; 0){
    this.<span class="apidocCodeKeywordSpan">makeCallback</span>(query.callback, &#x22;over queue limit&#x22;, null);
    query = null;
    return;
}

// generate a regular query,
var redundancy = this.redundancy &#x26;&#x26; this.redundancy &#x3c; this.servers.length
, queryRedundancy = query.redundancyEnabled
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memcached.memcached.prototype.multi" id="apidoc.element.memcached.memcached.prototype.multi">
        function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>multi
        <span class="apidocSignatureSpan">(keys, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function memcachedMulti(keys, callback) {
  var map = {}
    , memcached = this
    , servers
    , i;

  // gets all servers based on the supplied keys,
  // or just gives all servers if we don&#x27;t have keys
  if (keys) {
    keys.forEach(function fetchMultipleServers(key) {
      var server = memcached.servers.length === 1
        ? memcached.servers[0]
        : memcached.HashRing.get(key);

      if (map[server]){
        map[server].push(key);
      } else {
        map[server] = [key];
      }
    });

    // store the servers
    servers = Object.keys(map);
  } else {
    servers = this.servers;
  }

  i = servers.length;

  while (i--) {
     //memcached.delegateCallback(this, servers[i], map[servers[i]], i, servers.length, callback);
    callback.call(this, servers[i], map[servers[i]], i, servers.length);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
1. `server`: *String*, The server location.
2. `key`: *String*, The key associated with the server, if you didn&#x27;t specify
   keys, this variable will be undefined.
3. `index`: *Number*, The current index of the loop
4. `total`: *Number*, The total amount server retrieved.

``` js
memcached.<span class="apidocCodeKeywordSpan">multi</span>( false, function( server, key, index, totals ){
  if( err ) throw new Error( err );

  this.connect( server, function( err, conn ){
    console.log( &#x22;connection ready&#x22; )
  })
});
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memcached.memcached.prototype.prepend" id="apidoc.element.memcached.memcached.prototype.prepend">
        function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>prepend
        <span class="apidocSignatureSpan">(key, value, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function prepend(key, value, callback) {
  privates.setters.call(this
    , &#x27;prepend&#x27;
    , [
          [&#x27;key&#x27;, String]
        , [&#x27;value&#x27;, String]
        , [&#x27;lifetime&#x27;, Number]
        , [&#x27;callback&#x27;, Function]
      ]
    , key
    , value
    , 0
    , callback
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memcached.memcached.prototype.rawDataReceived" id="apidoc.element.memcached.memcached.prototype.rawDataReceived">
        function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>rawDataReceived
        <span class="apidocSignatureSpan">(S)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function rawDataReceived(S) {
  var queue = []
    , token
    , tokenSet
    , dataSet
    , resultSet
    , metaData
    , err = []
    , tmp;

  while(S.bufferArray.length &#x26;&#x26; privates.allCommands.test(S.bufferArray[0])) {
    token = S.bufferArray.shift();
    tokenSet = token.split(&#x27; &#x27;);

    if (/^\d+$/.test(tokenSet[0])) {
        // special case for &#x22;config get cluster&#x22;
        // Amazon-specific memcached configuration information, see aws
        // documentation regarding adding auto-discovery to your client library.
        // Example response of a cache cluster containing three nodes:
        //   configversion\n
        //   hostname|ip-address|port hostname|ip-address|port hostname|ip-address|port\n\r\n
        if (/(([-.a-zA-Z0-9]+)\|(\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b)\|(\d+))/.test(S.bufferArray[0])) {
            tokenSet.unshift(&#x27;CONFIG&#x27;);
        }
        // special case for digit only&#x27;s these are responses from INCR and DECR
        else {
          tokenSet.unshift(&#x27;INCRDECR&#x27;);
        }
    }
    // special case for value, it&#x27;s required that it has a second response!
    // add the token back, and wait for the next response, we might be
    // handling a big ass response here.
    if (tokenSet[0] === &#x27;VALUE&#x27; &#x26;&#x26; S.bufferArray.indexOf(&#x27;END&#x27;) === -1) {
      return S.bufferArray.unshift(token);
    }

    // check for dedicated parser
    if (privates.parsers[tokenSet[0]]) {

      // fetch the response content
      if (tokenSet[0] === &#x27;VALUE&#x27;) {
        dataSet = Utils.unescapeValue(S.bufferArray.shift());
      }

      resultSet = privates.parsers[tokenSet[0]].call(S, tokenSet, dataSet || token, err, queue, this);

      // check how we need to handle the resultSet response
      switch (resultSet.shift()) {
        case BUFFER:
          break;

        case FLUSH:
          metaData = S.metaData.shift();
          resultSet = queue;

          // if we have a callback, call it
          if (metaData &#x26;&#x26; metaData.callback) {
            metaData.execution = Date.now() - metaData.start;
              this.delegateCallback(
                metaData
              , err.length ? err : err[0]

                // see if optional parsing needs to be applied to make the result set more readable
              , privates.resultParsers[metaData.type]
                  ? privates.resultParsers[metaData.type].call(S, resultSet, err)
                  : !Array.isArray(queue) || queue.length &#x3e; 1 ? queue : queue[0]
              ,metaData.callback
            );
          }

          queue.length = err.length = 0;
          break;

        default:
          metaData = S.metaData.shift();

          if (metaData &#x26;&#x26; metaData.callback) {
            metaData.execution = Date.now() - metaData.start;
            this.delegateCallback(metaData, err.length &#x3e; 1 ? err : err[0], resultSet[0], metaData.callback);
          }

          err.length = 0;
          break;
      }
    } else {
      // handle unkown responses
      metaData = S.metaData.shift();
      if (metaData &#x26;&#x26; metaData.callback){
        metaData.execution = Date.now() - metaData.start;
          this.delegateCallback(metaData, new Error(&#x27;Unknown response from the memcached server: &#x22;&#x27; + token + &#x27;&#x22;&#x27;), false, metaData
.callback);
      }
    }

    // cleanup
    dataSet = tokenSet = metaData = undefined;

    // check if we need to remove an empty item from the array, as splitting on /r/n might cause an empty
    // item at the end..
    if (S.bufferArray[0] === &#x27;&#x27;) S.bufferArray.shift();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }

    // Fix zero-line endings in the middle
    var chunkLength = (chunks.length-1);
    if (chunks[chunkLength].length === 0) chunks.splice(chunkLength, 1);

    S.responseBuffer = &#x22;&#x22;; // clear!
    this.<span class="apidocCodeKeywordSpan">rawDataReceived</span>(S, S.bufferArray = S.bufferArray.concat(chunks));
  }
};

memcached.delegateCallback = function(){
      this.activeQueries--;
      var master = arguments[0];
      var cb = arguments[arguments.length-1];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memcached.memcached.prototype.replace" id="apidoc.element.memcached.memcached.prototype.replace">
        function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>replace
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bowlofcurry() {
  return fn.apply(context || this, args.concat(copy.call(arguments)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

* `key`: **String** the name of the key
* `value`: **Mixed** Either a buffer, JSON, number or string that you want to store.
* `lifetime`: **Number**, how long the data needs to be replaced measured in `seconds`
* `callback`: **Function** the callback

```js
memcached.<span class="apidocCodeKeywordSpan">replace</span>(&#x27;foo&#x27;, &#x27;bar&#x27;, 10, function (err) { /* stuff */ });
```

**memcached.add** Add the value, only if it&#x27;s not in memcached already.

* `key`: **String** the name of the key
* `value`: **Mixed** Either a buffer, JSON, number or string that you want to store.
* `lifetime`: **Number**, how long the data needs to be replaced measured in `seconds`
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memcached.memcached.prototype.set" id="apidoc.element.memcached.memcached.prototype.set">
        function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>set
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bowlofcurry() {
  return fn.apply(context || this, args.concat(copy.call(arguments)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

* `key`: **String** the name of the key
* `value`: **Mixed** Either a buffer, JSON, number or string that you want to store.
* `lifetime`: **Number**, how long the data needs to be stored measured in `seconds`
* `callback`: **Function** the callback

```js
memcached.<span class="apidocCodeKeywordSpan">set</span>(&#x27;foo&#x27;, &#x27;bar&#x27;, 10, function (err) { /* stuff */ });
```

**memcached.replace** Replaces the value in memcached.

* `key`: **String** the name of the key
* `value`: **Mixed** Either a buffer, JSON, number or string that you want to store.
* `lifetime`: **Number**, how long the data needs to be replaced measured in `seconds`
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memcached.memcached.prototype.settings" id="apidoc.element.memcached.memcached.prototype.settings">
        function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>settings
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bowlofcurry() {
  return fn.apply(context || this, args.concat(copy.call(arguments)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var	nMemcached = require( &#x27;../&#x27; ),
	memcached;

// connect to our memcached server on host 10.211.55.5, port 11211
memcached = new nMemcached( &#x22;10.211.55.5:11211&#x22; );

memcached.<span class="apidocCodeKeywordSpan">settings</span>( function( err, result ){
	if( err ) console.error( err );
	
	console.log( JSON.stringify ( result ));
	memcached.end(); // as we are 100% certain we are not going to use the connection again, we are going to end it
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memcached.memcached.prototype.slabs" id="apidoc.element.memcached.memcached.prototype.slabs">
        function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>slabs
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bowlofcurry() {
  return fn.apply(context || this, args.concat(copy.call(arguments)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var	nMemcached = require( &#x27;../&#x27; ),
	memcached;

// connect to our memcached server on host 10.211.55.5, port 11211
memcached = new nMemcached( &#x22;10.211.55.5:11211&#x22; );

memcached.<span class="apidocCodeKeywordSpan">slabs</span>( function( err, result ){
	if( err ) console.error( err );
	
	console.log( JSON.stringify ( result ));
	memcached.end(); // as we are 100% certain we are not going to use the connection again, we are going to end it
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memcached.memcached.prototype.stats" id="apidoc.element.memcached.memcached.prototype.stats">
        function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>stats
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bowlofcurry() {
  return fn.apply(context || this, args.concat(copy.call(arguments)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var	nMemcached = require( &#x27;../&#x27; ),
	memcached;

// connect to our memcached server on host 10.211.55.5, port 11211
memcached = new nMemcached( &#x22;10.211.55.5:11211&#x22; );

memcached.<span class="apidocCodeKeywordSpan">stats</span>( function( err, result ){
	if( err ) console.error( err );
	
	console.log( JSON.stringify ( result ));
	memcached.end(); // as we are 100% certain we are not going to use the connection again, we are going to end it
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memcached.memcached.prototype.statsItems" id="apidoc.element.memcached.memcached.prototype.statsItems">
        function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>statsItems
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bowlofcurry() {
  return fn.apply(context || this, args.concat(copy.call(arguments)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memcached.memcached.prototype.statsSettings" id="apidoc.element.memcached.memcached.prototype.statsSettings">
        function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>statsSettings
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bowlofcurry() {
  return fn.apply(context || this, args.concat(copy.call(arguments)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memcached.memcached.prototype.statsSlabs" id="apidoc.element.memcached.memcached.prototype.statsSlabs">
        function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>statsSlabs
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bowlofcurry() {
  return fn.apply(context || this, args.concat(copy.call(arguments)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memcached.memcached.prototype.touch" id="apidoc.element.memcached.memcached.prototype.touch">
        function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>touch
        <span class="apidocSignatureSpan">(key, lifetime, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function touch(key, lifetime, callback) {
  var fullkey = this.namespace + key;
  this.command(function touchCommand() {
    return {
        key: fullkey
      , callback: callback
      , lifetime: lifetime
      , validate: [[&#x27;key&#x27;, String], [&#x27;lifetime&#x27;, Number], [&#x27;callback&#x27;, Function]]
      , type: &#x27;touch&#x27;
      , command: [&#x27;touch&#x27;, fullkey, lifetime].join(&#x27; &#x27;)
    };
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
**memcached.touch** Touches the given key.

* `key`: **String** The key
* `lifetime`: **Number** After how long should the key expire measured in `seconds`
* `callback`: **Function**

```js
memcached.<span class="apidocCodeKeywordSpan">touch</span>(&#x27;key&#x27;, 10, function (err) { /* stuff */ });
```

**memcached.get** Get the value for the given key.

* `key`: **String**, the key
* `callback`: **Function**, the callback.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memcached.memcached.prototype.version" id="apidoc.element.memcached.memcached.prototype.version">
        function <span class="apidocSignatureSpan">memcached.memcached.prototype.</span>version
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bowlofcurry() {
  return fn.apply(context || this, args.concat(copy.call(arguments)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var	nMemcached = require( &#x27;../&#x27; ),
	memcached;

// connect to our memcached server on host 10.211.55.5, port 11211
memcached = new nMemcached( &#x22;10.211.55.5:11211&#x22; );

memcached.<span class="apidocCodeKeywordSpan">version</span>( function( err, result ){
	if( err ) console.error( err );
	
	console.log( JSON.stringify ( result ));
	memcached.end(); // as we are 100% certain we are not going to use the connection again, we are going to end it
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.memcached.utils" id="apidoc.module.memcached.utils">module memcached.utils</a></h1>


    <h2>
        <a href="#apidoc.element.memcached.utils.Iterator" id="apidoc.element.memcached.utils.Iterator">
        function <span class="apidocSignatureSpan">memcached.utils.</span>Iterator
        <span class="apidocSignatureSpan">(collection, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function iterator(collection, callback) {
  var arr = Array.isArray(collection)
    , keys = !arr ? Object.keys(collection) : false
    , index = 0
    , maximum = arr ? collection.length : keys.length
    , self = this;

  // returns next item
  this.next = function next () {
    var obj = arr ? collection[index] : { key: keys[index], value: collection[keys[index]] };
    callback(obj, index++, collection, self);
  };

  // check if we have more items
  this.hasNext = function hasNext () {
    return index &#x3c; maximum;
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memcached.utils.curry" id="apidoc.element.memcached.utils.curry">
        function <span class="apidocSignatureSpan">memcached.utils.</span>curry
        <span class="apidocSignatureSpan">(context, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function curry(context, fn) {
  var copy = Array.prototype.slice
    , args = copy.call(arguments, 2);

  return function bowlofcurry () {
    return fn.apply(context || this, args.concat(copy.call(arguments)));
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memcached.utils.escapeValue" id="apidoc.element.memcached.utils.escapeValue">
        function <span class="apidocSignatureSpan">memcached.utils.</span>escapeValue
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">escapeValue = function (value) {
  return value.replace(/(\r|\n)/g, &#x27;\\$1&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  flag = FLAG_NUMERIC;
  value = value.toString();
} else if (valuetype !== &#x27;string&#x27;) {
  flag = FLAG_JSON;
  value = JSON.stringify(value);
}

value = Utils.<span class="apidocCodeKeywordSpan">escapeValue</span>(value);

length = Buffer.byteLength(value);
if (length &#x3e; this.maxValue) {
  return privates.errorResponse(new Error(&#x27;The length of the value is greater than &#x27; + this.maxValue), callback);
}

this.command(function settersCommand(noreply) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memcached.utils.fuse" id="apidoc.element.memcached.utils.fuse">
        function <span class="apidocSignatureSpan">memcached.utils.</span>fuse
        <span class="apidocSignatureSpan">(target, handlers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fuse(target, handlers) {
  for (var i in handlers)
    if (handlers.hasOwnProperty(i)){
      target.on(i, handlers[i]);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
S.responseBuffer = &#x22;&#x22;;
S.bufferArray = [];
S.serverAddress = server;
S.tokens = [].concat(serverTokens);
S.memcached = memcached;

// Add the event listeners
Utils.<span class="apidocCodeKeywordSpan">fuse</span>(S, {
    close: function streamClose() {
      Manager.remove(this);
    }
  , data: curry(memcached, privates.buffer, S)
  , connect: function streamConnect() {
      // Jackpot handles any pre-connect timeouts by calling back
      // with the error object.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memcached.utils.merge" id="apidoc.element.memcached.utils.merge">
        function <span class="apidocSignatureSpan">memcached.utils.</span>merge
        <span class="apidocSignatureSpan">(target, obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function merge(target, obj) {
  for (var i in obj) {
    target[i] = obj[i];
  }

  return target;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.isScheduledToReconnect = false;

  this.totalFailures = 0;
  this.retry = 0;
  this.totalReconnectsAttempted = 0;
  this.totalReconnectsSuccess = 0;

  Utils.<span class="apidocCodeKeywordSpan">merge</span>(this, args);
  EventEmitter.call(this);
}

util.inherits(IssueLog, EventEmitter);
var issues = IssueLog.prototype;

issues.log = function log (message) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memcached.utils.reallocString" id="apidoc.element.memcached.utils.reallocString">
        function <span class="apidocSignatureSpan">memcached.utils.</span>reallocString
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reallocString = function (value) {
  // Reallocate string to fix slow string operations in node 0.10
  // see https://code.google.com/p/v8/issues/detail?id=2869 for details
  return (&#x27; &#x27; + value).substr(1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    memcached.connectionIssue(message, S);
    return query.callback &#x26;&#x26; memcached.makeCallback(query.callback,new Error(message));
  }

  // used for request timing
  query.start = Date.now();
  S.metaData.push(query);
  S.write(Utils.<span class="apidocCodeKeywordSpan">reallocString</span>(query.command + LINEBREAK));
});

// if we have redundancy enabled and the query is used for redundancy, than
// we are going loop over the servers, check if we can reach them, and
// connect to the correct net connection. because all redundancy queries are
// executed with &#x22;no reply&#x22; we do not need to store the callback as there
// will be no value to parse.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memcached.utils.unescapeValue" id="apidoc.element.memcached.utils.unescapeValue">
        function <span class="apidocSignatureSpan">memcached.utils.</span>unescapeValue
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unescapeValue = function (value) {
  return value.replace(/\\(\r|\n)/g, &#x27;$1&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }

      // check for dedicated parser
      if (privates.parsers[tokenSet[0]]) {

// fetch the response content
if (tokenSet[0] === &#x27;VALUE&#x27;) {
  dataSet = Utils.<span class="apidocCodeKeywordSpan">unescapeValue</span>(S.bufferArray.shift());
}

resultSet = privates.parsers[tokenSet[0]].call(S, tokenSet, dataSet || token, err, queue, this);

// check how we need to handle the resultSet response
switch (resultSet.shift()) {
  case BUFFER:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memcached.utils.validateArg" id="apidoc.element.memcached.utils.validateArg">
        function <span class="apidocSignatureSpan">memcached.utils.</span>validateArg
        <span class="apidocSignatureSpan">(args, config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function validateArg(args, config) {
  var err;

  args.validate.forEach(function (tokens) {
    var key = tokens[0]
      , value = args[key];

    switch(tokens[1]){
      case Number:
        if (toString.call(value) !== &#x27;[object Number]&#x27;) {
          err = &#x27;Argument &#x22;&#x27; + key + &#x27;&#x22; is not a valid Number.&#x27;;
        }

        break;

      case Boolean:
        if (toString.call(value) !== &#x27;[object Boolean]&#x27;) {
          err = &#x27;Argument &#x22;&#x27; + key + &#x27;&#x22; is not a valid Boolean.&#x27;;
        }

        break;

      case Array:
        if (toString.call(value) !== &#x27;[object Array]&#x27;) {
          err = &#x27;Argument &#x22;&#x27; + key + &#x27;&#x22; is not a valid Array.&#x27;;
        }
        if (!err &#x26;&#x26; key === &#x27;key&#x27;) {
          for (var vKey=0; vKey&#x3c;value.length; vKey++) {
            var vValue = value[vKey];
            var result = validateKeySize(config, vKey, vValue);
            if (result.err) {
              err = result.err;
            } else {
              args.command = args.command.replace(vValue, result[&#x27;value&#x27;]);
            }
          }
        }
        break;

      case Object:
        if (toString.call(value) !== &#x27;[object Object]&#x27;) {
          err = &#x27;Argument &#x22;&#x27; + key + &#x27;&#x22; is not a valid Object.&#x27;;
        }

        break;

      case Function:
        if (toString.call(value) !== &#x27;[object Function]&#x27;) {
          err = &#x27;Argument &#x22;&#x27; + key + &#x27;&#x22; is not a valid Function.&#x27;;
        }

        break;

      case String:
        if (toString.call(value) !== &#x27;[object String]&#x27;) {
          err = &#x27;Argument &#x22;&#x27; + key + &#x27;&#x22; is not a valid String.&#x27;;
        }

        if (!err &#x26;&#x26; key === &#x27;key&#x27;) {
          var result = validateKeySize(config, key, value);
          if (result.err) {
            err = result.err;
          } else {
            args.command = reallocString(args.command).replace(value, result[&#x27;value&#x27;]);
          }
        }
        break;

      default:
        if (toString.call(value) === &#x27;[object global]&#x27; &#x26;&#x26; !tokens[2]) {
          err = &#x27;Argument &#x22;&#x27; + key + &#x27;&#x22; is not defined.&#x27;;
        }
    }
  });

  if (err){
    if (args.callback) args.callback(new Error(err));
    return false;
  }

  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  // generate a regular query,
  var redundancy = this.redundancy &#x26;&#x26; this.redundancy &#x3c; this.servers.length
  , queryRedundancy = query.redundancyEnabled
  , memcached = this;

// validate the arguments
if (query.validate &#x26;&#x26; !Utils.<span class="apidocCodeKeywordSpan">validateArg</span>(query, this)) {
    this.activeQueries--;
    return;
}

// try to find the correct server for this query
if (!server) {
  // no need to do a hashring lookup if we only have one server assigned to
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
